// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: domains.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkDomainAvailability = `-- name: CheckDomainAvailability :one
SELECT NOT EXISTS(
    SELECT 1 FROM app_domains
    WHERE domain = $1
) as is_available
`

func (q *Queries) CheckDomainAvailability(ctx context.Context, domain string) (bool, error) {
	row := q.db.QueryRow(ctx, checkDomainAvailability, domain)
	var is_available bool
	err := row.Scan(&is_available)
	return is_available, err
}

const createAppDomain = `-- name: CreateAppDomain :one
INSERT INTO app_domains (
    app_id,
    domain,
    domain_source,
    subdomain_label,
    platform_domain_id,
    is_primary
)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, app_id, domain, domain_source, subdomain_label, platform_domain_id, is_primary, created_at, updated_at
`

type CreateAppDomainParams struct {
	AppID            int64        `json:"appId"`
	Domain           string       `json:"domain"`
	DomainSource     DomainSource `json:"domainSource"`
	SubdomainLabel   pgtype.Text  `json:"subdomainLabel"`
	PlatformDomainID pgtype.Int8  `json:"platformDomainId"`
	IsPrimary        bool         `json:"isPrimary"`
}

func (q *Queries) CreateAppDomain(ctx context.Context, arg CreateAppDomainParams) (AppDomain, error) {
	row := q.db.QueryRow(ctx, createAppDomain,
		arg.AppID,
		arg.Domain,
		arg.DomainSource,
		arg.SubdomainLabel,
		arg.PlatformDomainID,
		arg.IsPrimary,
	)
	var i AppDomain
	err := row.Scan(
		&i.ID,
		&i.AppID,
		&i.Domain,
		&i.DomainSource,
		&i.SubdomainLabel,
		&i.PlatformDomainID,
		&i.IsPrimary,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPlatformDomain = `-- name: CreatePlatformDomain :one
INSERT INTO platform_domains (domain, is_active)
VALUES ($1, $2)
RETURNING id, domain, is_active, created_at
`

type CreatePlatformDomainParams struct {
	Domain   string `json:"domain"`
	IsActive bool   `json:"isActive"`
}

func (q *Queries) CreatePlatformDomain(ctx context.Context, arg CreatePlatformDomainParams) (PlatformDomain, error) {
	row := q.db.QueryRow(ctx, createPlatformDomain, arg.Domain, arg.IsActive)
	var i PlatformDomain
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const deactivatePlatformDomain = `-- name: DeactivatePlatformDomain :one
UPDATE platform_domains
SET is_active = false
WHERE id = $1
RETURNING id, domain, is_active, created_at
`

func (q *Queries) DeactivatePlatformDomain(ctx context.Context, id int64) (PlatformDomain, error) {
	row := q.db.QueryRow(ctx, deactivatePlatformDomain, id)
	var i PlatformDomain
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAppDomain = `-- name: DeleteAppDomain :exec
DELETE FROM app_domains WHERE id = $1
`

func (q *Queries) DeleteAppDomain(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteAppDomain, id)
	return err
}

const getAppDomainByID = `-- name: GetAppDomainByID :one
SELECT 
    ad.id,
    ad.app_id,
    ad.domain,
    ad.domain_source,
    ad.subdomain_label,
    ad.platform_domain_id,
    ad.is_primary,
    ad.created_at,
    ad.updated_at
FROM app_domains ad
WHERE ad.id = $1
`

func (q *Queries) GetAppDomainByID(ctx context.Context, id int64) (AppDomain, error) {
	row := q.db.QueryRow(ctx, getAppDomainByID, id)
	var i AppDomain
	err := row.Scan(
		&i.ID,
		&i.AppID,
		&i.Domain,
		&i.DomainSource,
		&i.SubdomainLabel,
		&i.PlatformDomainID,
		&i.IsPrimary,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAppDomainCount = `-- name: GetAppDomainCount :one
SELECT COUNT(*) as count FROM app_domains WHERE app_id = $1
`

func (q *Queries) GetAppDomainCount(ctx context.Context, appID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getAppDomainCount, appID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getDomainByAppId = `-- name: GetDomainByAppId :one
SELECT 
    ad.id, ad.app_id, ad.domain, ad.domain_source, ad.subdomain_label, ad.platform_domain_id, ad.is_primary, ad.created_at, ad.updated_at,
    pd.domain as platform_base_domain
FROM app_domains ad
LEFT JOIN platform_domains pd ON ad.platform_domain_id = pd.id
WHERE ad.app_id = $1
`

type GetDomainByAppIdRow struct {
	ID                 int64              `json:"id"`
	AppID              int64              `json:"appId"`
	Domain             string             `json:"domain"`
	DomainSource       DomainSource       `json:"domainSource"`
	SubdomainLabel     pgtype.Text        `json:"subdomainLabel"`
	PlatformDomainID   pgtype.Int8        `json:"platformDomainId"`
	IsPrimary          bool               `json:"isPrimary"`
	CreatedAt          pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt          pgtype.Timestamptz `json:"updatedAt"`
	PlatformBaseDomain pgtype.Text        `json:"platformBaseDomain"`
}

func (q *Queries) GetDomainByAppId(ctx context.Context, appID int64) (GetDomainByAppIdRow, error) {
	row := q.db.QueryRow(ctx, getDomainByAppId, appID)
	var i GetDomainByAppIdRow
	err := row.Scan(
		&i.ID,
		&i.AppID,
		&i.Domain,
		&i.DomainSource,
		&i.SubdomainLabel,
		&i.PlatformDomainID,
		&i.IsPrimary,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PlatformBaseDomain,
	)
	return i, err
}

const getPlatformDomain = `-- name: GetPlatformDomain :one
SELECT id, domain, is_active, created_at FROM platform_domains
WHERE id = $1
`

func (q *Queries) GetPlatformDomain(ctx context.Context, id int64) (PlatformDomain, error) {
	row := q.db.QueryRow(ctx, getPlatformDomain, id)
	var i PlatformDomain
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getPlatformDomainByName = `-- name: GetPlatformDomainByName :one
SELECT id, domain, is_active, created_at FROM platform_domains
WHERE domain = $1
`

func (q *Queries) GetPlatformDomainByName(ctx context.Context, domain string) (PlatformDomain, error) {
	row := q.db.QueryRow(ctx, getPlatformDomainByName, domain)
	var i PlatformDomain
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const listActivePlatformDomains = `-- name: ListActivePlatformDomains :many
SELECT id, domain, is_active, created_at FROM platform_domains
WHERE is_active = true
ORDER BY domain
`

func (q *Queries) ListActivePlatformDomains(ctx context.Context) ([]PlatformDomain, error) {
	rows, err := q.db.Query(ctx, listActivePlatformDomains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlatformDomain
	for rows.Next() {
		var i PlatformDomain
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllLocoOwnedDomains = `-- name: ListAllLocoOwnedDomains :many
SELECT 
    ad.id,
    ad.domain,
    a.name as app_name,
    a.id as app_id,
    pd.domain as platform_domain
FROM app_domains ad
JOIN apps a ON ad.app_id = a.id
JOIN platform_domains pd ON ad.platform_domain_id = pd.id
WHERE ad.domain_source = 'platform_provided'
ORDER BY ad.created_at DESC
`

type ListAllLocoOwnedDomainsRow struct {
	ID             int64  `json:"id"`
	Domain         string `json:"domain"`
	AppName        string `json:"appName"`
	AppID          int64  `json:"appId"`
	PlatformDomain string `json:"platformDomain"`
}

func (q *Queries) ListAllLocoOwnedDomains(ctx context.Context) ([]ListAllLocoOwnedDomainsRow, error) {
	rows, err := q.db.Query(ctx, listAllLocoOwnedDomains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllLocoOwnedDomainsRow
	for rows.Next() {
		var i ListAllLocoOwnedDomainsRow
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.AppName,
			&i.AppID,
			&i.PlatformDomain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppDomains = `-- name: ListAppDomains :many
SELECT 
    ad.id,
    ad.app_id,
    ad.domain,
    ad.domain_source,
    ad.subdomain_label,
    ad.platform_domain_id,
    ad.is_primary,
    ad.created_at,
    ad.updated_at
FROM app_domains ad
WHERE ad.app_id = $1
ORDER BY ad.is_primary DESC, ad.created_at ASC
`

func (q *Queries) ListAppDomains(ctx context.Context, appID int64) ([]AppDomain, error) {
	rows, err := q.db.Query(ctx, listAppDomains, appID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppDomain
	for rows.Next() {
		var i AppDomain
		if err := rows.Scan(
			&i.ID,
			&i.AppID,
			&i.Domain,
			&i.DomainSource,
			&i.SubdomainLabel,
			&i.PlatformDomainID,
			&i.IsPrimary,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setAppDomainPrimary = `-- name: SetAppDomainPrimary :one
UPDATE app_domains
SET is_primary = true
WHERE id = $1 AND app_id = $2
RETURNING id, app_id, domain, domain_source, subdomain_label, platform_domain_id, is_primary, created_at, updated_at
`

type SetAppDomainPrimaryParams struct {
	ID    int64 `json:"id"`
	AppID int64 `json:"appId"`
}

func (q *Queries) SetAppDomainPrimary(ctx context.Context, arg SetAppDomainPrimaryParams) (AppDomain, error) {
	row := q.db.QueryRow(ctx, setAppDomainPrimary, arg.ID, arg.AppID)
	var i AppDomain
	err := row.Scan(
		&i.ID,
		&i.AppID,
		&i.Domain,
		&i.DomainSource,
		&i.SubdomainLabel,
		&i.PlatformDomainID,
		&i.IsPrimary,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAppDomain = `-- name: UpdateAppDomain :one
UPDATE app_domains
SET domain = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, app_id, domain, domain_source, subdomain_label, platform_domain_id, is_primary, created_at, updated_at
`

type UpdateAppDomainParams struct {
	ID     int64  `json:"id"`
	Domain string `json:"domain"`
}

func (q *Queries) UpdateAppDomain(ctx context.Context, arg UpdateAppDomainParams) (AppDomain, error) {
	row := q.db.QueryRow(ctx, updateAppDomain, arg.ID, arg.Domain)
	var i AppDomain
	err := row.Scan(
		&i.ID,
		&i.AppID,
		&i.Domain,
		&i.DomainSource,
		&i.SubdomainLabel,
		&i.PlatformDomainID,
		&i.IsPrimary,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAppDomainPrimary = `-- name: UpdateAppDomainPrimary :exec
UPDATE app_domains
SET is_primary = false
WHERE app_id = $1
`

func (q *Queries) UpdateAppDomainPrimary(ctx context.Context, appID int64) error {
	_, err := q.db.Exec(ctx, updateAppDomainPrimary, appID)
	return err
}
