// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: domains.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkDomainAvailability = `-- name: CheckDomainAvailability :one
SELECT NOT EXISTS(
    SELECT 1 FROM resource_domains
    WHERE domain = $1
) as is_available
`

func (q *Queries) CheckDomainAvailability(ctx context.Context, domain string) (bool, error) {
	row := q.db.QueryRow(ctx, checkDomainAvailability, domain)
	var is_available bool
	err := row.Scan(&is_available)
	return is_available, err
}

const createPlatformDomain = `-- name: CreatePlatformDomain :one
INSERT INTO platform_domains (domain, is_active)
VALUES ($1, $2)
RETURNING id
`

type CreatePlatformDomainParams struct {
	Domain   string `json:"domain"`
	IsActive bool   `json:"isActive"`
}

func (q *Queries) CreatePlatformDomain(ctx context.Context, arg CreatePlatformDomainParams) (int64, error) {
	row := q.db.QueryRow(ctx, createPlatformDomain, arg.Domain, arg.IsActive)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createResourceDomain = `-- name: CreateResourceDomain :one
INSERT INTO resource_domains (
    resource_id,
    domain,
    domain_source,
    subdomain_label,
    platform_domain_id,
    is_primary
)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

type CreateResourceDomainParams struct {
	ResourceID       int64        `json:"resourceId"`
	Domain           string       `json:"domain"`
	DomainSource     DomainSource `json:"domainSource"`
	SubdomainLabel   pgtype.Text  `json:"subdomainLabel"`
	PlatformDomainID pgtype.Int8  `json:"platformDomainId"`
	IsPrimary        bool         `json:"isPrimary"`
}

func (q *Queries) CreateResourceDomain(ctx context.Context, arg CreateResourceDomainParams) (int64, error) {
	row := q.db.QueryRow(ctx, createResourceDomain,
		arg.ResourceID,
		arg.Domain,
		arg.DomainSource,
		arg.SubdomainLabel,
		arg.PlatformDomainID,
		arg.IsPrimary,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deactivatePlatformDomain = `-- name: DeactivatePlatformDomain :one
UPDATE platform_domains
SET is_active = false
WHERE id = $1
RETURNING id
`

func (q *Queries) DeactivatePlatformDomain(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, deactivatePlatformDomain, id)
	err := row.Scan(&id)
	return id, err
}

const deleteResourceDomain = `-- name: DeleteResourceDomain :exec
DELETE FROM resource_domains WHERE id = $1
`

func (q *Queries) DeleteResourceDomain(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteResourceDomain, id)
	return err
}

const getDomainByResourceId = `-- name: GetDomainByResourceId :one
SELECT 
    rd.id, rd.resource_id, rd.domain, rd.domain_source, rd.subdomain_label, rd.platform_domain_id, rd.is_primary, rd.created_at, rd.updated_at,
    pd.domain as platform_base_domain
FROM resource_domains rd
LEFT JOIN platform_domains pd ON rd.platform_domain_id = pd.id
WHERE rd.resource_id = $1
`

type GetDomainByResourceIdRow struct {
	ID                 int64              `json:"id"`
	ResourceID         int64              `json:"resourceId"`
	Domain             string             `json:"domain"`
	DomainSource       DomainSource       `json:"domainSource"`
	SubdomainLabel     pgtype.Text        `json:"subdomainLabel"`
	PlatformDomainID   pgtype.Int8        `json:"platformDomainId"`
	IsPrimary          bool               `json:"isPrimary"`
	CreatedAt          pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt          pgtype.Timestamptz `json:"updatedAt"`
	PlatformBaseDomain pgtype.Text        `json:"platformBaseDomain"`
}

func (q *Queries) GetDomainByResourceId(ctx context.Context, resourceID int64) (GetDomainByResourceIdRow, error) {
	row := q.db.QueryRow(ctx, getDomainByResourceId, resourceID)
	var i GetDomainByResourceIdRow
	err := row.Scan(
		&i.ID,
		&i.ResourceID,
		&i.Domain,
		&i.DomainSource,
		&i.SubdomainLabel,
		&i.PlatformDomainID,
		&i.IsPrimary,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PlatformBaseDomain,
	)
	return i, err
}

const getPlatformDomain = `-- name: GetPlatformDomain :one
SELECT id, domain, is_active, created_at FROM platform_domains
WHERE id = $1
`

func (q *Queries) GetPlatformDomain(ctx context.Context, id int64) (PlatformDomain, error) {
	row := q.db.QueryRow(ctx, getPlatformDomain, id)
	var i PlatformDomain
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getPlatformDomainByName = `-- name: GetPlatformDomainByName :one
SELECT id, domain, is_active, created_at FROM platform_domains
WHERE domain = $1
`

func (q *Queries) GetPlatformDomainByName(ctx context.Context, domain string) (PlatformDomain, error) {
	row := q.db.QueryRow(ctx, getPlatformDomainByName, domain)
	var i PlatformDomain
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getResourceDomainByID = `-- name: GetResourceDomainByID :one
SELECT 
    rd.id,
    rd.resource_id,
    rd.domain,
    rd.domain_source,
    rd.subdomain_label,
    rd.platform_domain_id,
    rd.is_primary,
    rd.created_at,
    rd.updated_at
FROM resource_domains rd
WHERE rd.id = $1
`

func (q *Queries) GetResourceDomainByID(ctx context.Context, id int64) (ResourceDomain, error) {
	row := q.db.QueryRow(ctx, getResourceDomainByID, id)
	var i ResourceDomain
	err := row.Scan(
		&i.ID,
		&i.ResourceID,
		&i.Domain,
		&i.DomainSource,
		&i.SubdomainLabel,
		&i.PlatformDomainID,
		&i.IsPrimary,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getResourceDomainCount = `-- name: GetResourceDomainCount :one
SELECT COUNT(*) as count FROM resource_domains WHERE resource_id = $1
`

func (q *Queries) GetResourceDomainCount(ctx context.Context, resourceID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getResourceDomainCount, resourceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listActivePlatformDomains = `-- name: ListActivePlatformDomains :many
SELECT id, domain, is_active, created_at FROM platform_domains
WHERE is_active = true
ORDER BY domain
`

func (q *Queries) ListActivePlatformDomains(ctx context.Context) ([]PlatformDomain, error) {
	rows, err := q.db.Query(ctx, listActivePlatformDomains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlatformDomain
	for rows.Next() {
		var i PlatformDomain
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllLocoOwnedDomains = `-- name: ListAllLocoOwnedDomains :many
SELECT 
    rd.id,
    rd.domain,
    r.name as resource_name,
    r.id as resource_id,
    pd.domain as platform_domain
FROM resource_domains rd
JOIN resources r ON rd.resource_id = r.id
JOIN platform_domains pd ON rd.platform_domain_id = pd.id
WHERE rd.domain_source = 'platform_provided'
ORDER BY rd.created_at DESC
`

type ListAllLocoOwnedDomainsRow struct {
	ID             int64  `json:"id"`
	Domain         string `json:"domain"`
	ResourceName   string `json:"resourceName"`
	ResourceID     int64  `json:"resourceId"`
	PlatformDomain string `json:"platformDomain"`
}

func (q *Queries) ListAllLocoOwnedDomains(ctx context.Context) ([]ListAllLocoOwnedDomainsRow, error) {
	rows, err := q.db.Query(ctx, listAllLocoOwnedDomains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllLocoOwnedDomainsRow
	for rows.Next() {
		var i ListAllLocoOwnedDomainsRow
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.ResourceName,
			&i.ResourceID,
			&i.PlatformDomain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlatformDomains = `-- name: ListPlatformDomains :many
SELECT id, domain, is_active, created_at FROM platform_domains
WHERE ($1::boolean IS NULL OR is_active = $1::boolean)
ORDER BY domain
`

func (q *Queries) ListPlatformDomains(ctx context.Context, activeOnly pgtype.Bool) ([]PlatformDomain, error) {
	rows, err := q.db.Query(ctx, listPlatformDomains, activeOnly)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlatformDomain
	for rows.Next() {
		var i PlatformDomain
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourceDomains = `-- name: ListResourceDomains :many
SELECT 
    rd.id,
    rd.resource_id,
    rd.domain,
    rd.domain_source,
    rd.subdomain_label,
    rd.platform_domain_id,
    rd.is_primary,
    rd.created_at,
    rd.updated_at
FROM resource_domains rd
WHERE rd.resource_id = $1
ORDER BY rd.is_primary DESC, rd.created_at ASC
`

func (q *Queries) ListResourceDomains(ctx context.Context, resourceID int64) ([]ResourceDomain, error) {
	rows, err := q.db.Query(ctx, listResourceDomains, resourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ResourceDomain
	for rows.Next() {
		var i ResourceDomain
		if err := rows.Scan(
			&i.ID,
			&i.ResourceID,
			&i.Domain,
			&i.DomainSource,
			&i.SubdomainLabel,
			&i.PlatformDomainID,
			&i.IsPrimary,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setResourceDomainPrimary = `-- name: SetResourceDomainPrimary :one
UPDATE resource_domains
SET is_primary = true
WHERE id = $1 AND resource_id = $2
RETURNING id
`

type SetResourceDomainPrimaryParams struct {
	ID         int64 `json:"id"`
	ResourceID int64 `json:"resourceId"`
}

func (q *Queries) SetResourceDomainPrimary(ctx context.Context, arg SetResourceDomainPrimaryParams) (int64, error) {
	row := q.db.QueryRow(ctx, setResourceDomainPrimary, arg.ID, arg.ResourceID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateResourceDomain = `-- name: UpdateResourceDomain :one
UPDATE resource_domains
SET domain = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id
`

type UpdateResourceDomainParams struct {
	ID     int64  `json:"id"`
	Domain string `json:"domain"`
}

func (q *Queries) UpdateResourceDomain(ctx context.Context, arg UpdateResourceDomainParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateResourceDomain, arg.ID, arg.Domain)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateResourceDomainPrimary = `-- name: UpdateResourceDomainPrimary :exec
UPDATE resource_domains
SET is_primary = false
WHERE resource_id = $1
`

func (q *Queries) UpdateResourceDomainPrimary(ctx context.Context, resourceID int64) error {
	_, err := q.db.Exec(ctx, updateResourceDomainPrimary, resourceID)
	return err
}
