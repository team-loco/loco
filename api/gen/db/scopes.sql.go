// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: scopes.sql

package db

import (
	"context"
)

const addUserScope = `-- name: AddUserScope :exec
INSERT INTO user_scopes (user_id, scope, entity_type, entity_id) VALUES ($1, $2, $3, $4) ON CONFLICT DO NOTHING
`

type AddUserScopeParams struct {
	UserID     int64      `json:"userId"`
	Scope      string     `json:"scope"`
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

func (q *Queries) AddUserScope(ctx context.Context, arg AddUserScopeParams) error {
	_, err := q.db.Exec(ctx, addUserScope,
		arg.UserID,
		arg.Scope,
		arg.EntityType,
		arg.EntityID,
	)
	return err
}

const getUserScopes = `-- name: GetUserScopes :many

SELECT scope, entity_type, entity_id FROM user_scopes WHERE user_id = $1
`

type GetUserScopesRow struct {
	Scope      string     `json:"scope"`
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

// what scopes does user x have?
func (q *Queries) GetUserScopes(ctx context.Context, userID int64) ([]GetUserScopesRow, error) {
	rows, err := q.db.Query(ctx, getUserScopes, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserScopesRow
	for rows.Next() {
		var i GetUserScopesRow
		if err := rows.Scan(&i.Scope, &i.EntityType, &i.EntityID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserScopesOnEntity = `-- name: GetUserScopesOnEntity :many

SELECT scope FROM user_scopes WHERE user_id = $1 AND entity_type = $2 AND entity_id = $3
`

type GetUserScopesOnEntityParams struct {
	UserID     int64      `json:"userId"`
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

// what scopes does user x have on entity y?
func (q *Queries) GetUserScopesOnEntity(ctx context.Context, arg GetUserScopesOnEntityParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getUserScopesOnEntity, arg.UserID, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var scope string
		if err := rows.Scan(&scope); err != nil {
			return nil, err
		}
		items = append(items, scope)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithScopeOnEntity = `-- name: GetUsersWithScopeOnEntity :many

SELECT user_id FROM user_scopes WHERE entity_type = $1 AND entity_id = $2 AND scope = $3
`

type GetUsersWithScopeOnEntityParams struct {
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
	Scope      string     `json:"scope"`
}

// what users have scope z on entity y?
func (q *Queries) GetUsersWithScopeOnEntity(ctx context.Context, arg GetUsersWithScopeOnEntityParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, getUsersWithScopeOnEntity, arg.EntityType, arg.EntityID, arg.Scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var user_id int64
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllScopesForEntity = `-- name: RemoveAllScopesForEntity :exec
DELETE FROM user_scopes WHERE entity_type = $1 AND entity_id = $2
`

type RemoveAllScopesForEntityParams struct {
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

func (q *Queries) RemoveAllScopesForEntity(ctx context.Context, arg RemoveAllScopesForEntityParams) error {
	_, err := q.db.Exec(ctx, removeAllScopesForEntity, arg.EntityType, arg.EntityID)
	return err
}

const removeAllScopesForUserOnEntity = `-- name: RemoveAllScopesForUserOnEntity :exec
DELETE FROM user_scopes WHERE user_id = $1 AND entity_type = $2 AND entity_id = $3
`

type RemoveAllScopesForUserOnEntityParams struct {
	UserID     int64      `json:"userId"`
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

func (q *Queries) RemoveAllScopesForUserOnEntity(ctx context.Context, arg RemoveAllScopesForUserOnEntityParams) error {
	_, err := q.db.Exec(ctx, removeAllScopesForUserOnEntity, arg.UserID, arg.EntityType, arg.EntityID)
	return err
}

const removeUserScope = `-- name: RemoveUserScope :exec
DELETE FROM user_scopes WHERE user_id = $1 AND scope = $2 AND entity_type = $3 AND entity_id = $4
`

type RemoveUserScopeParams struct {
	UserID     int64      `json:"userId"`
	Scope      string     `json:"scope"`
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

func (q *Queries) RemoveUserScope(ctx context.Context, arg RemoveUserScopeParams) error {
	_, err := q.db.Exec(ctx, removeUserScope,
		arg.UserID,
		arg.Scope,
		arg.EntityType,
		arg.EntityID,
	)
	return err
}
