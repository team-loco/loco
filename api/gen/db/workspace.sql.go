// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: workspace.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteWorkspaceMember = `-- name: DeleteWorkspaceMember :exec
DELETE FROM workspace_members
WHERE workspace_id = $1 AND user_id = $2
`

type DeleteWorkspaceMemberParams struct {
	WorkspaceID int64 `json:"workspaceId"`
	UserID      int64 `json:"userId"`
}

func (q *Queries) DeleteWorkspaceMember(ctx context.Context, arg DeleteWorkspaceMemberParams) error {
	_, err := q.db.Exec(ctx, deleteWorkspaceMember, arg.WorkspaceID, arg.UserID)
	return err
}

const getWorkspaceByIDQuery = `-- name: GetWorkspaceByIDQuery :one
SELECT id, org_id, name, description, created_by, created_at, updated_at FROM workspaces WHERE id = $1
`

func (q *Queries) GetWorkspaceByIDQuery(ctx context.Context, id int64) (Workspace, error) {
	row := q.db.QueryRow(ctx, getWorkspaceByIDQuery, id)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Description,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWorkspaceMemberRole = `-- name: GetWorkspaceMemberRole :one
SELECT role FROM workspace_members
WHERE workspace_id = $1 AND user_id = $2
`

type GetWorkspaceMemberRoleParams struct {
	WorkspaceID int64 `json:"workspaceId"`
	UserID      int64 `json:"userId"`
}

func (q *Queries) GetWorkspaceMemberRole(ctx context.Context, arg GetWorkspaceMemberRoleParams) (WorkspaceRole, error) {
	row := q.db.QueryRow(ctx, getWorkspaceMemberRole, arg.WorkspaceID, arg.UserID)
	var role WorkspaceRole
	err := row.Scan(&role)
	return role, err
}

const getWorkspaceMembers = `-- name: GetWorkspaceMembers :many
SELECT workspace_id, user_id, role, created_at
FROM workspace_members
WHERE workspace_id = $1
`

func (q *Queries) GetWorkspaceMembers(ctx context.Context, workspaceID int64) ([]WorkspaceMember, error) {
	rows, err := q.db.Query(ctx, getWorkspaceMembers, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkspaceMember
	for rows.Next() {
		var i WorkspaceMember
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.UserID,
			&i.Role,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspaceOrgID = `-- name: GetWorkspaceOrgID :one

SELECT org_id FROM workspaces WHERE id = $1
`

// TODO: Uncomment when apps table exists
// -- name: CountAppsInWorkspace :one
// SELECT COUNT(*) FROM apps WHERE workspace_id = $1;
func (q *Queries) GetWorkspaceOrgID(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getWorkspaceOrgID, id)
	var org_id int64
	err := row.Scan(&org_id)
	return org_id, err
}

const insertWorkspace = `-- name: InsertWorkspace :one
INSERT INTO workspaces (org_id, name, description, created_by)
VALUES ($1, $2, $3, $4)
RETURNING id, org_id, name, description, created_by, created_at, updated_at
`

type InsertWorkspaceParams struct {
	OrgID       int64       `json:"orgId"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	CreatedBy   int64       `json:"createdBy"`
}

func (q *Queries) InsertWorkspace(ctx context.Context, arg InsertWorkspaceParams) (Workspace, error) {
	row := q.db.QueryRow(ctx, insertWorkspace,
		arg.OrgID,
		arg.Name,
		arg.Description,
		arg.CreatedBy,
	)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Description,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const isWorkspaceMember = `-- name: IsWorkspaceMember :one
SELECT EXISTS(
  SELECT 1 FROM workspace_members
  WHERE workspace_id = $1 AND user_id = $2
) as is_member
`

type IsWorkspaceMemberParams struct {
	WorkspaceID int64 `json:"workspaceId"`
	UserID      int64 `json:"userId"`
}

func (q *Queries) IsWorkspaceMember(ctx context.Context, arg IsWorkspaceMemberParams) (bool, error) {
	row := q.db.QueryRow(ctx, isWorkspaceMember, arg.WorkspaceID, arg.UserID)
	var is_member bool
	err := row.Scan(&is_member)
	return is_member, err
}

const isWorkspaceNameUniqueInOrg = `-- name: IsWorkspaceNameUniqueInOrg :one
SELECT COUNT(*) = 0 as is_unique
FROM workspaces
WHERE org_id = $1
AND name = $2
`

type IsWorkspaceNameUniqueInOrgParams struct {
	OrgID int64  `json:"orgId"`
	Name  string `json:"name"`
}

func (q *Queries) IsWorkspaceNameUniqueInOrg(ctx context.Context, arg IsWorkspaceNameUniqueInOrgParams) (bool, error) {
	row := q.db.QueryRow(ctx, isWorkspaceNameUniqueInOrg, arg.OrgID, arg.Name)
	var is_unique bool
	err := row.Scan(&is_unique)
	return is_unique, err
}

const listWorkspaceMembersWithUserDetails = `-- name: ListWorkspaceMembersWithUserDetails :many
SELECT wm.workspace_id, wm.user_id, wm.role, wm.created_at,
       u.name, u.email, u.avatar_url
FROM workspace_members wm
JOIN users u ON wm.user_id = u.id
WHERE wm.workspace_id = $1
  AND ($3 IS NULL OR wm.user_id > $3)
ORDER BY wm.user_id ASC
LIMIT $2
`

type ListWorkspaceMembersWithUserDetailsParams struct {
	WorkspaceID int64       `json:"workspaceId"`
	Limit       int32       `json:"limit"`
	AfterCursor interface{} `json:"afterCursor"`
}

type ListWorkspaceMembersWithUserDetailsRow struct {
	WorkspaceID int64              `json:"workspaceId"`
	UserID      int64              `json:"userId"`
	Role        WorkspaceRole      `json:"role"`
	CreatedAt   pgtype.Timestamptz `json:"createdAt"`
	Name        pgtype.Text        `json:"name"`
	Email       string             `json:"email"`
	AvatarUrl   pgtype.Text        `json:"avatarUrl"`
}

func (q *Queries) ListWorkspaceMembersWithUserDetails(ctx context.Context, arg ListWorkspaceMembersWithUserDetailsParams) ([]ListWorkspaceMembersWithUserDetailsRow, error) {
	rows, err := q.db.Query(ctx, listWorkspaceMembersWithUserDetails, arg.WorkspaceID, arg.Limit, arg.AfterCursor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWorkspaceMembersWithUserDetailsRow
	for rows.Next() {
		var i ListWorkspaceMembersWithUserDetailsRow
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.UserID,
			&i.Role,
			&i.CreatedAt,
			&i.Name,
			&i.Email,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkspacesForUser = `-- name: ListWorkspacesForUser :many
SELECT DISTINCT w.id, w.org_id, w.name, w.description, w.created_by, w.created_at, w.updated_at
FROM workspaces w
JOIN workspace_members wm ON wm.workspace_id = w.id
WHERE wm.user_id = $1
ORDER BY w.created_at DESC
`

func (q *Queries) ListWorkspacesForUser(ctx context.Context, userID int64) ([]Workspace, error) {
	rows, err := q.db.Query(ctx, listWorkspacesForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Workspace
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Name,
			&i.Description,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkspacesInOrg = `-- name: ListWorkspacesInOrg :many
SELECT id, org_id, name, description, created_by, created_at, updated_at FROM workspaces
WHERE org_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListWorkspacesInOrg(ctx context.Context, orgID int64) ([]Workspace, error) {
	rows, err := q.db.Query(ctx, listWorkspacesInOrg, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Workspace
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Name,
			&i.Description,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeWorkspace = `-- name: RemoveWorkspace :exec
DELETE FROM workspaces WHERE id = $1
`

func (q *Queries) RemoveWorkspace(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, removeWorkspace, id)
	return err
}

const updateWorkspace = `-- name: UpdateWorkspace :one
UPDATE workspaces
SET name = COALESCE($2, name),
    description = COALESCE($3, description),
    updated_at = NOW()
WHERE id = $1
RETURNING id, org_id, name, description, created_by, created_at, updated_at
`

type UpdateWorkspaceParams struct {
	ID          int64       `json:"id"`
	Name        pgtype.Text `json:"name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) UpdateWorkspace(ctx context.Context, arg UpdateWorkspaceParams) (Workspace, error) {
	row := q.db.QueryRow(ctx, updateWorkspace, arg.ID, arg.Name, arg.Description)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Description,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertWorkspaceMember = `-- name: UpsertWorkspaceMember :one
INSERT INTO workspace_members (workspace_id, user_id, role)
VALUES ($1, $2, $3)
ON CONFLICT (workspace_id, user_id)
DO UPDATE SET role = EXCLUDED.role
RETURNING workspace_id, user_id, role, created_at
`

type UpsertWorkspaceMemberParams struct {
	WorkspaceID int64         `json:"workspaceId"`
	UserID      int64         `json:"userId"`
	Role        WorkspaceRole `json:"role"`
}

func (q *Queries) UpsertWorkspaceMember(ctx context.Context, arg UpsertWorkspaceMemberParams) (WorkspaceMember, error) {
	row := q.db.QueryRow(ctx, upsertWorkspaceMember, arg.WorkspaceID, arg.UserID, arg.Role)
	var i WorkspaceMember
	err := row.Scan(
		&i.WorkspaceID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}
