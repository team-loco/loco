// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tvm.sql

package db

import (
	"context"
	"time"
)

const addUserScope = `-- name: AddUserScope :exec
INSERT INTO user_scopes (user_id, scope, entity_type, entity_id) VALUES ($1, $2, $3, $4) ON CONFLICT DO NOTHING
`

type AddUserScopeParams struct {
	UserID     int64      `json:"userId"`
	Scope      string     `json:"scope"`
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

func (q *Queries) AddUserScope(ctx context.Context, arg AddUserScopeParams) error {
	_, err := q.db.Exec(ctx, addUserScope,
		arg.UserID,
		arg.Scope,
		arg.EntityType,
		arg.EntityID,
	)
	return err
}

const deleteExpiredTokens = `-- name: DeleteExpiredTokens :exec
DELETE FROM tokens WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredTokens)
	return err
}

const deleteToken = `-- name: DeleteToken :exec
DELETE FROM tokens WHERE token = $1
`

func (q *Queries) DeleteToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, deleteToken, token)
	return err
}

const deleteTokensForEntity = `-- name: DeleteTokensForEntity :exec
DELETE FROM tokens WHERE entity_type = $1 AND entity_id = $2
`

type DeleteTokensForEntityParams struct {
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

func (q *Queries) DeleteTokensForEntity(ctx context.Context, arg DeleteTokensForEntityParams) error {
	_, err := q.db.Exec(ctx, deleteTokensForEntity, arg.EntityType, arg.EntityID)
	return err
}

const getToken = `-- name: GetToken :one
SELECT scopes, entity_type, entity_id, expires_at FROM tokens WHERE token = $1
`

type GetTokenRow struct {
	Scopes     []EntityScope `json:"scopes"`
	EntityType EntityType    `json:"entityType"`
	EntityID   int64         `json:"entityId"`
	ExpiresAt  time.Time     `json:"expiresAt"`
}

func (q *Queries) GetToken(ctx context.Context, token string) (GetTokenRow, error) {
	row := q.db.QueryRow(ctx, getToken, token)
	var i GetTokenRow
	err := row.Scan(
		&i.Scopes,
		&i.EntityType,
		&i.EntityID,
		&i.ExpiresAt,
	)
	return i, err
}

const getTokensForEntity = `-- name: GetTokensForEntity :many
SELECT token FROM tokens WHERE entity_type = $1 AND entity_id = $2
`

type GetTokensForEntityParams struct {
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

// which tokens exist on behalf of entity y?
func (q *Queries) GetTokensForEntity(ctx context.Context, arg GetTokensForEntityParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getTokensForEntity, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var token string
		if err := rows.Scan(&token); err != nil {
			return nil, err
		}
		items = append(items, token)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserScopes = `-- name: GetUserScopes :many
SELECT user_id, scope, entity_type, entity_id FROM user_scopes WHERE user_id = $1
`

// what scopes does user x have?
func (q *Queries) GetUserScopes(ctx context.Context, userID int64) ([]UserScope, error) {
	rows, err := q.db.Query(ctx, getUserScopes, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserScope
	for rows.Next() {
		var i UserScope
		if err := rows.Scan(
			&i.UserID,
			&i.Scope,
			&i.EntityType,
			&i.EntityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserScopesByEmail = `-- name: GetUserScopesByEmail :many
SELECT us.user_id, us.scope, us.entity_type, us.entity_id
FROM user_scopes us
JOIN users u ON us.user_id = u.id
WHERE u.email = $1
`

func (q *Queries) GetUserScopesByEmail(ctx context.Context, email string) ([]UserScope, error) {
	rows, err := q.db.Query(ctx, getUserScopesByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserScope
	for rows.Next() {
		var i UserScope
		if err := rows.Scan(
			&i.UserID,
			&i.Scope,
			&i.EntityType,
			&i.EntityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserScopesOnEntity = `-- name: GetUserScopesOnEntity :many
SELECT user_id, scope, entity_type, entity_id FROM user_scopes WHERE user_id = $1 AND entity_type = $2 AND entity_id = $3
`

type GetUserScopesOnEntityParams struct {
	UserID     int64      `json:"userId"`
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

// what scopes does user x have on entity y?
func (q *Queries) GetUserScopesOnEntity(ctx context.Context, arg GetUserScopesOnEntityParams) ([]UserScope, error) {
	rows, err := q.db.Query(ctx, getUserScopesOnEntity, arg.UserID, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserScope
	for rows.Next() {
		var i UserScope
		if err := rows.Scan(
			&i.UserID,
			&i.Scope,
			&i.EntityType,
			&i.EntityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserScopesOnOrganization = `-- name: GetUserScopesOnOrganization :many
WITH RECURSIVE entity_hierarchy AS (
    -- Base case: the organization itself
    SELECT 
        'organization'::entity_type as entity_type,
        o.id as entity_id,
        o.name as entity_name
    FROM organizations o
    WHERE o.id = $1
    
    UNION ALL
    
    -- Workspaces in the organization
    SELECT 
        'workspace'::entity_type,
        w.id,
        w.name
    FROM workspaces w
    INNER JOIN entity_hierarchy eh ON eh.entity_type = 'organization' AND eh.entity_id = w.org_id
    
    UNION ALL
    
    -- Apps in the workspaces
    SELECT 
        'app'::entity_type,
        a.id,
        a.name
    FROM apps a
    INNER JOIN entity_hierarchy eh ON eh.entity_type = 'workspace' AND eh.entity_id = a.workspace_id
)
SELECT DISTINCT
    us.user_id,
    us.scope,
    us.entity_type,
    us.entity_id
FROM user_scopes us
INNER JOIN entity_hierarchy eh ON us.entity_type = eh.entity_type AND us.entity_id = eh.entity_id
WHERE us.user_id = $2
ORDER BY us.entity_type, us.entity_id, us.scope
`

type GetUserScopesOnOrganizationParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"userId"`
}

func (q *Queries) GetUserScopesOnOrganization(ctx context.Context, arg GetUserScopesOnOrganizationParams) ([]UserScope, error) {
	rows, err := q.db.Query(ctx, getUserScopesOnOrganization, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserScope
	for rows.Next() {
		var i UserScope
		if err := rows.Scan(
			&i.UserID,
			&i.Scope,
			&i.EntityType,
			&i.EntityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserScopesOnWorkspace = `-- name: GetUserScopesOnWorkspace :many
WITH RECURSIVE entity_hierarchy AS (
    -- Base case: the workspace itself
    SELECT 
        'workspace'::entity_type as entity_type,
        w.id as entity_id,
        w.name as entity_name
    FROM workspaces w
    WHERE w.id = $1
    
    UNION ALL
    
    -- Apps in the workspace
    SELECT 
        'app'::entity_type,
        a.id,
        a.name
    FROM apps a
    INNER JOIN entity_hierarchy eh ON eh.entity_type = 'workspace' AND eh.entity_id = a.workspace_id
)
SELECT DISTINCT
    us.user_id,
    us.scope,
    us.entity_type,
    us.entity_id
FROM user_scopes us
INNER JOIN entity_hierarchy eh ON us.entity_type = eh.entity_type AND us.entity_id = eh.entity_id
WHERE us.user_id = $2
ORDER BY us.entity_type, us.entity_id, us.scope
`

type GetUserScopesOnWorkspaceParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"userId"`
}

func (q *Queries) GetUserScopesOnWorkspace(ctx context.Context, arg GetUserScopesOnWorkspaceParams) ([]UserScope, error) {
	rows, err := q.db.Query(ctx, getUserScopesOnWorkspace, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserScope
	for rows.Next() {
		var i UserScope
		if err := rows.Scan(
			&i.UserID,
			&i.Scope,
			&i.EntityType,
			&i.EntityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithScopeOnEntity = `-- name: GetUsersWithScopeOnEntity :many
SELECT user_id FROM user_scopes WHERE entity_type = $1 AND entity_id = $2 AND scope = $3
`

type GetUsersWithScopeOnEntityParams struct {
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
	Scope      string     `json:"scope"`
}

// what users have scope z on entity y?
func (q *Queries) GetUsersWithScopeOnEntity(ctx context.Context, arg GetUsersWithScopeOnEntityParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, getUsersWithScopeOnEntity, arg.EntityType, arg.EntityID, arg.Scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var user_id int64
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllScopesForEntity = `-- name: RemoveAllScopesForEntity :exec
DELETE FROM user_scopes WHERE entity_type = $1 AND entity_id = $2
`

type RemoveAllScopesForEntityParams struct {
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

func (q *Queries) RemoveAllScopesForEntity(ctx context.Context, arg RemoveAllScopesForEntityParams) error {
	_, err := q.db.Exec(ctx, removeAllScopesForEntity, arg.EntityType, arg.EntityID)
	return err
}

const removeAllScopesForUserOnEntity = `-- name: RemoveAllScopesForUserOnEntity :exec
DELETE FROM user_scopes WHERE user_id = $1 AND entity_type = $2 AND entity_id = $3
`

type RemoveAllScopesForUserOnEntityParams struct {
	UserID     int64      `json:"userId"`
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

func (q *Queries) RemoveAllScopesForUserOnEntity(ctx context.Context, arg RemoveAllScopesForUserOnEntityParams) error {
	_, err := q.db.Exec(ctx, removeAllScopesForUserOnEntity, arg.UserID, arg.EntityType, arg.EntityID)
	return err
}

const removeUserScope = `-- name: RemoveUserScope :exec
DELETE FROM user_scopes WHERE user_id = $1 AND scope = $2 AND entity_type = $3 AND entity_id = $4
`

type RemoveUserScopeParams struct {
	UserID     int64      `json:"userId"`
	Scope      string     `json:"scope"`
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

func (q *Queries) RemoveUserScope(ctx context.Context, arg RemoveUserScopeParams) error {
	_, err := q.db.Exec(ctx, removeUserScope,
		arg.UserID,
		arg.Scope,
		arg.EntityType,
		arg.EntityID,
	)
	return err
}

const storeToken = `-- name: StoreToken :exec
INSERT INTO tokens (token, entity_type, entity_id, scopes, expires_at) VALUES ($1, $2, $3, $4, $5) ON CONFLICT DO NOTHING
`

type StoreTokenParams struct {
	Token      string        `json:"token"`
	EntityType EntityType    `json:"entityType"`
	EntityID   int64         `json:"entityId"`
	Scopes     []EntityScope `json:"scopes"`
	ExpiresAt  time.Time     `json:"expiresAt"`
}

func (q *Queries) StoreToken(ctx context.Context, arg StoreTokenParams) error {
	_, err := q.db.Exec(ctx, storeToken,
		arg.Token,
		arg.EntityType,
		arg.EntityID,
		arg.Scopes,
		arg.ExpiresAt,
	)
	return err
}
