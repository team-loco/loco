// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tvm.sql

package db

import (
	"context"
	"time"
)

const addUserScope = `-- name: AddUserScope :exec
INSERT INTO user_scopes (user_id, scope, entity_type, entity_id) VALUES ($1, $2, $3, $4) ON CONFLICT DO NOTHING
`

type AddUserScopeParams struct {
	UserID     int64      `json:"userId"`
	Scope      Scope      `json:"scope"`
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

func (q *Queries) AddUserScope(ctx context.Context, arg AddUserScopeParams) error {
	_, err := q.db.Exec(ctx, addUserScope,
		arg.UserID,
		arg.Scope,
		arg.EntityType,
		arg.EntityID,
	)
	return err
}

const deleteExpiredTokens = `-- name: DeleteExpiredTokens :exec
DELETE FROM tokens WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredTokens)
	return err
}

const deleteToken = `-- name: DeleteToken :exec
DELETE FROM tokens WHERE name = $1
`

func (q *Queries) DeleteToken(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, deleteToken, name)
	return err
}

const deleteTokensForEntity = `-- name: DeleteTokensForEntity :exec
DELETE FROM tokens WHERE entity_type = $1 AND entity_id = $2
`

type DeleteTokensForEntityParams struct {
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

func (q *Queries) DeleteTokensForEntity(ctx context.Context, arg DeleteTokensForEntityParams) error {
	_, err := q.db.Exec(ctx, deleteTokensForEntity, arg.EntityType, arg.EntityID)
	return err
}

const getToken = `-- name: GetToken :one
SELECT name, token, scopes, entity_type, entity_id, expires_at FROM tokens WHERE token = $1 AND expires_at > NOW()
`

func (q *Queries) GetToken(ctx context.Context, token string) (Token, error) {
	row := q.db.QueryRow(ctx, getToken, token)
	var i Token
	err := row.Scan(
		&i.Name,
		&i.Token,
		&i.Scopes,
		&i.EntityType,
		&i.EntityID,
		&i.ExpiresAt,
	)
	return i, err
}

const getUserScopes = `-- name: GetUserScopes :many
SELECT jsonb_build_object(
    'scope', scope,
    'entity_type', entity_type,
    'entity_id', entity_id
)::entity_scope
FROM user_scopes
WHERE user_id = $1
`

// what scopes does user x have?
func (q *Queries) GetUserScopes(ctx context.Context, userID int64) ([]EntityScope, error) {
	rows, err := q.db.Query(ctx, getUserScopes, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EntityScope
	for rows.Next() {
		var column_1 EntityScope
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserScopesOnEntity = `-- name: GetUserScopesOnEntity :many
SELECT jsonb_build_object(
    'scope', scope,
    'entity_type', entity_type,
    'entity_id', entity_id
)::entity_scope
FROM user_scopes WHERE user_id = $1 AND entity_type = $2 AND entity_id = $3
`

type GetUserScopesOnEntityParams struct {
	UserID     int64      `json:"userId"`
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

// what scopes does user x have on entity y?
func (q *Queries) GetUserScopesOnEntity(ctx context.Context, arg GetUserScopesOnEntityParams) ([]EntityScope, error) {
	rows, err := q.db.Query(ctx, getUserScopesOnEntity, arg.UserID, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EntityScope
	for rows.Next() {
		var column_1 EntityScope
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserScopesOnOrganization = `-- name: GetUserScopesOnOrganization :many
WITH RECURSIVE entity_hierarchy AS (
    -- Base case: the organization itself
    SELECT 
        'organization'::entity_type as entity_type,
        o.id as entity_id,
        o.name as entity_name
    FROM organizations o
    WHERE o.id = $1
    
    UNION ALL
    
    -- Workspaces in the organization
    SELECT 
        'workspace'::entity_type,
        w.id,
        w.name
    FROM workspaces w
    INNER JOIN entity_hierarchy eh ON eh.entity_type = 'organization' AND eh.entity_id = w.org_id
    
    UNION ALL
    
    -- Resources in the workspaces
    SELECT 
        'resource'::entity_type,
        r.id,
        r.name
    FROM resources r
    INNER JOIN entity_hierarchy eh ON eh.entity_type = 'workspace' AND eh.entity_id = r.workspace_id
)
SELECT DISTINCT
    jsonb_build_object(
        'scope', us.scope,
        'entity_type', us.entity_type,
        'entity_id', us.entity_id
    )::entity_scope
FROM user_scopes us
INNER JOIN entity_hierarchy eh ON us.entity_type = eh.entity_type AND us.entity_id = eh.entity_id
WHERE us.user_id = $2
ORDER BY us.entity_type, us.entity_id, us.scope
`

type GetUserScopesOnOrganizationParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"userId"`
}

func (q *Queries) GetUserScopesOnOrganization(ctx context.Context, arg GetUserScopesOnOrganizationParams) ([]EntityScope, error) {
	rows, err := q.db.Query(ctx, getUserScopesOnOrganization, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EntityScope
	for rows.Next() {
		var column_1 EntityScope
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserScopesOnWorkspace = `-- name: GetUserScopesOnWorkspace :many
WITH RECURSIVE entity_hierarchy AS (
    -- Base case: the workspace itself
    SELECT 
        'workspace'::entity_type as entity_type,
        w.id as entity_id,
        w.name as entity_name
    FROM workspaces w
    WHERE w.id = $1
    
    UNION ALL
    
    -- Resources in the workspace
    SELECT 
        'resource'::entity_type,
        r.id,
        r.name
    FROM resources r
    INNER JOIN entity_hierarchy eh ON eh.entity_type = 'workspace' AND eh.entity_id = r.workspace_id
)
SELECT DISTINCT
    jsonb_build_object(
        'scope', us.scope,
        'entity_type', us.entity_type,
        'entity_id', us.entity_id
    )::entity_scope
FROM user_scopes us
INNER JOIN entity_hierarchy eh ON us.entity_type = eh.entity_type AND us.entity_id = eh.entity_id
WHERE us.user_id = $2
ORDER BY us.entity_type, us.entity_id, us.scope
`

type GetUserScopesOnWorkspaceParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"userId"`
}

func (q *Queries) GetUserScopesOnWorkspace(ctx context.Context, arg GetUserScopesOnWorkspaceParams) ([]EntityScope, error) {
	rows, err := q.db.Query(ctx, getUserScopesOnWorkspace, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EntityScope
	for rows.Next() {
		var column_1 EntityScope
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithScopesByEmail = `-- name: GetUserWithScopesByEmail :one
SELECT id, external_id, email, name, avatar_url, created_at, updated_at, scopes FROM user_with_scopes_view WHERE email = $1
`

func (q *Queries) GetUserWithScopesByEmail(ctx context.Context, email string) (UserWithScopesView, error) {
	row := q.db.QueryRow(ctx, getUserWithScopesByEmail, email)
	var i UserWithScopesView
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Email,
		&i.Name,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Scopes,
	)
	return i, err
}

const getUsersWithScopeOnEntity = `-- name: GetUsersWithScopeOnEntity :many
SELECT user_id FROM user_scopes WHERE entity_type = $1 AND entity_id = $2 AND scope = $3
`

type GetUsersWithScopeOnEntityParams struct {
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
	Scope      Scope      `json:"scope"`
}

// what users have scope z on entity y?
func (q *Queries) GetUsersWithScopeOnEntity(ctx context.Context, arg GetUsersWithScopeOnEntityParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, getUsersWithScopeOnEntity, arg.EntityType, arg.EntityID, arg.Scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var user_id int64
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTokensForEntity = `-- name: ListTokensForEntity :many
SELECT name, entity_type, entity_id, scopes, expires_at FROM tokens WHERE entity_type = $1 AND entity_id = $2
`

type ListTokensForEntityParams struct {
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

type ListTokensForEntityRow struct {
	Name       string        `json:"name"`
	EntityType EntityType    `json:"entityType"`
	EntityID   int64         `json:"entityId"`
	Scopes     []EntityScope `json:"scopes"`
	ExpiresAt  time.Time     `json:"expiresAt"`
}

// which tokens exist on behalf of entity y?
func (q *Queries) ListTokensForEntity(ctx context.Context, arg ListTokensForEntityParams) ([]ListTokensForEntityRow, error) {
	rows, err := q.db.Query(ctx, listTokensForEntity, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTokensForEntityRow
	for rows.Next() {
		var i ListTokensForEntityRow
		if err := rows.Scan(
			&i.Name,
			&i.EntityType,
			&i.EntityID,
			&i.Scopes,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllScopesForEntity = `-- name: RemoveAllScopesForEntity :exec
DELETE FROM user_scopes WHERE entity_type = $1 AND entity_id = $2
`

type RemoveAllScopesForEntityParams struct {
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

func (q *Queries) RemoveAllScopesForEntity(ctx context.Context, arg RemoveAllScopesForEntityParams) error {
	_, err := q.db.Exec(ctx, removeAllScopesForEntity, arg.EntityType, arg.EntityID)
	return err
}

const removeAllScopesForUserOnEntity = `-- name: RemoveAllScopesForUserOnEntity :exec
DELETE FROM user_scopes WHERE user_id = $1 AND entity_type = $2 AND entity_id = $3
`

type RemoveAllScopesForUserOnEntityParams struct {
	UserID     int64      `json:"userId"`
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

func (q *Queries) RemoveAllScopesForUserOnEntity(ctx context.Context, arg RemoveAllScopesForUserOnEntityParams) error {
	_, err := q.db.Exec(ctx, removeAllScopesForUserOnEntity, arg.UserID, arg.EntityType, arg.EntityID)
	return err
}

const removeUserScope = `-- name: RemoveUserScope :exec
DELETE FROM user_scopes WHERE user_id = $1 AND scope = $2 AND entity_type = $3 AND entity_id = $4
`

type RemoveUserScopeParams struct {
	UserID     int64      `json:"userId"`
	Scope      Scope      `json:"scope"`
	EntityType EntityType `json:"entityType"`
	EntityID   int64      `json:"entityId"`
}

func (q *Queries) RemoveUserScope(ctx context.Context, arg RemoveUserScopeParams) error {
	_, err := q.db.Exec(ctx, removeUserScope,
		arg.UserID,
		arg.Scope,
		arg.EntityType,
		arg.EntityID,
	)
	return err
}

const storeToken = `-- name: StoreToken :exec
INSERT INTO tokens (name, token, entity_type, entity_id, scopes, expires_at) VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT DO NOTHING
`

type StoreTokenParams struct {
	Name       string        `json:"name"`
	Token      string        `json:"token"`
	EntityType EntityType    `json:"entityType"`
	EntityID   int64         `json:"entityId"`
	Scopes     []EntityScope `json:"scopes"`
	ExpiresAt  time.Time     `json:"expiresAt"`
}

func (q *Queries) StoreToken(ctx context.Context, arg StoreTokenParams) error {
	_, err := q.db.Exec(ctx, storeToken,
		arg.Name,
		arg.Token,
		arg.EntityType,
		arg.EntityID,
		arg.Scopes,
		arg.ExpiresAt,
	)
	return err
}
